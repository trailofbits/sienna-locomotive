""" Module handling !exploitable"""

import subprocess
import os

import autoit.autoit as autoit
import autoit.autoit_lib as autoit_lib
import utils.file_manipulation as file_manipulation
import utils.logs as logging
import utils.database as database

WINDBG_PATH32 = ""
WINDBG_PATH64 = ""

# cdb.exe: user mode debuger with command line interface
DEBUG = "cdb.exe"

# Run the program, load the MSEC dll, run !exploitable and quit
WINDBG_CMD = r"g;!load winext\MSEC.dll;!exploitable;q"


def init(config_system):
    """
    Initialize the module

    Args:
        config_system (dict): The system configuration
    """

    global WINDBG_PATH32
    global WINDBG_PATH64
    autoit.init(config_system)
    WINDBG_PATH32 = os.path.join(config_system['path_windbg'], 'x86')
    WINDBG_PATH64 = os.path.join(config_system['path_windbg'], 'x64')


def run(path_program, program_name, parameters, arch):
    """
    Run !exploitable

    Args:
        path_program (string): path the to the program
        program_name (string): name of the program
        parameters (string list): parameters of the script
        arch (string): architecture of the program (x86 or x64)
    Returns:
        string: exploitability verdict
    """
    if arch == "x86":
        windbg_bin = os.path.join(WINDBG_PATH32, DEBUG)
    elif arch == "x64":
        windbg_bin = os.path.join(WINDBG_PATH64, DEBUG)
    else:
        logging.error("Arch not supported " + arch)
        exit(0)
    cmd = [windbg_bin, "-c", WINDBG_CMD,
           os.path.join(path_program, program_name)] + parameters
    logging.debug('Run !exploitable: '+str(cmd))
    print 'Run !exploitable: '+str(cmd)
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE)
    classification = "Not found"
    for line in iter(proc.stdout.readline, b''):
        # detect when !exploitable analysis starts
        print line
        if line.startswith("!exploitable "):
            break
    for line in iter(proc.stdout.readline, b''):
        if line.startswith("Exploitability Classification:"):
            classification = line.rstrip()[30:]
    proc.wait()
    return classification


def run_autoit(autoit_script, path_program,
               program_name, parameters, input_file, arch):
    """
    Run !exploitable with an auto it script

    Args:
        autoit_script (string): path the to script
        path_program (string): path the to the program
        program_name (string): name of the program
        parameters (string list): parameters of the script
        input_file (string): input file
        arch (string): architecture of the program (x86 or x64)
    Returns:
        string: exploitability verdict
    """
    if arch == "x86":
        windbg_bin = os.path.join(WINDBG_PATH32, DEBUG)
    elif arch == "x64":
        windbg_bin = os.path.join(WINDBG_PATH64, DEBUG)
    else:
        logging.error("Arch not supported " + arch)
        exit(0)
    cmd = [windbg_bin, "-c", WINDBG_CMD,
           os.path.join(path_program, program_name)] + parameters
    logging.debug('Run !exploitable: '+str(cmd))
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE)

    autoit_script = autoit_lib.get_autoit_path(autoit_script, "exploitable")
    autoit.run(autoit_script, input_file)

    classification = "Not found"
    for line in iter(proc.stdout.readline, b''):
        # detect when !exploitable analysis starts
        print line
        if line.startswith("!exploitable "):
            break
    for line in iter(proc.stdout.readline, b''):
        if line.startswith("Exploitability Classification:"):
            classification = line.rstrip()[30:]
    proc.wait()
    return classification


def generate_classification(crash_file, classification):
    """
    Generate the classfication in the format to be sent to the webapp

    Args:
        crash_file (string): name of the file
        classification (string): result of !exploitable
    Returns:
        dict: dict to be sent
    """

    ret = {'crash_file': crash_file, 'classification': classification}
    return {'crash_classified': ret}


def launch_exploitable(config):
    """
    Launch !exploitable on all the crash files in the crash_dir
    Send the results to the webapp

    Args:
        config (dict): The user configuration
    """
    crash_dir = config['crash_dir']
    files = [f for f in os.listdir(crash_dir)
             if os.path.isfile(os.path.join(crash_dir, f))
             and f.endswith(config['file_format'])]
    for crash_file in files:
        if config['using_autoit']:
            parameters = [os.path.join(crash_dir, crash_file)]
            path_autoit_script = autoit_lib.get_autoit_path(
                config['path_autoit_script'], "exploitable")
            classification = run_autoit(path_autoit_script,
                                        config[
                                            'path_program'],
                                        config[
                                            'program_name'],
                                        config[
                                            'parameters'],
                                        parameters,
                                        config['arch'])
        else:
            parameters = file_manipulation.generate_parameters(
                config['parameters'], os.path.join(crash_dir, crash_file))
            classification = run(config['path_program'],
                                 config['program_name'],
                                 parameters,
                                 config['arch'])
        logging.info("Classification: " + classification)
        data = generate_classification(crash_file, classification)
        database.send_classification(config, data)
