#ifndef XploitabilityBangExploitable_H
#define XploitabilityBangExploitable_H

#include "Xploitability.h"
#include <functional>
#include <string>
#include <sstream>

using namespace std;


namespace sl2 {


#define DONT_CARE   0
enum ProcessorMode {
    DONT_CARE_PROCESSOR_MODE = DONT_CARE,
    KERNEL,
    USER
};

enum ExceptionAddressRange {
    DONT_CARE_EXCEPTION_ADDRESS_RANGE = DONT_CARE,
    IN_KERNEL_MEMORY,
    IN_USER_MEMORY,
    NEAR_NULL,
    NOT_NEAR_NULL
};

enum ExceptionType {
    DONT_CARE_EXCEPTION_TYPE = DONT_CARE,
    STATUS_ACCESS_VIOLATION,
    STATUS_BREAKPOINT,
    STATUS_FLOAT_DIVIDE_BY_ZERO,
    STATUS_GUARD_PAGE_VIOLATION,
    STATUS_HEAP_CORRUPTION,
    STATUS_ILLEGAL_INSTRUCTION,
    STATUS_INTEGER_DIVIDE_BY_ZERO,
    STATUS_PRIVILEGED_INSTRUCTION,
    STATUS_STACK_BUFFER_OVERRUN,
    STATUS_STACK_OVERFLOW,
    STATUS_WAKE_SYSTEM_DEBUGGER,
    STATUS_WX86_BREAKPOINT,
    STATUS_UNKNOWN
};

enum ExceptionSubtype {
    DONT_CARE_EXCEPTION_SUBTYPE = DONT_CARE,
    ACCESS_VIOLATION_TYPE_DEP,
    ACCESS_VIOLATION_TYPE_READ,
    ACCESS_VIOLATION_TYPE_WRITE
};


enum ExceptionLevel {
    DONT_CARE_EXCEPTION_LEVEL = DONT_CARE,
    FIRST_CHANCE,
    SECOND_CHANCE
};

//typedef   function<bool()>     AnalyzeFunction;


enum ResultClassification {
    EXPLOITABLE,
    NOT_AN_EXCEPTION,
    NOT_LIKELY_EXPLOITABLE,
    PROBABLY_EXPLOITABLE,
    UNKNOWN
};




class BangRule {
public:    
    ProcessorMode           processorMode;              // 1
    ExceptionAddressRange   exceptionAddressRange;      // 2
    ExceptionType           exceptionType;              // 3
    ExceptionSubtype        exceptionSubtype;           // 4
    ExceptionLevel          exceptionLevel;             // 5
    function<bool()>        analyzeFunction;            // 6
    ResultClassification    resultClassification;       // 7
    string	                resultDescription;          // 8
    string                  resultDescriptonShort;      // 9
    string                  resultExplaination;         // 10
    bool                    isFinal;                    // 11

    string                  toString() {
        ostringstream stream;
        stream << this;
        return stream.str();
    };


    ExceptionType           toExceptionType() {

    };
    

    friend string operator~(BangRule& self ) {
        return self.resultDescriptonShort;
    }  

    friend ostream& operator<<( ostream& os, BangRule& self ) {
        os << self.resultDescriptonShort;
        return os;
    }

};






////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// XploitabilityBangExploitable()
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class XploitabilityBangExploitable : public Xploitability {
public:
    
    XploitabilityBangExploitable( Minidump* dmp, ProcessState* state );

    virtual XploitabilityRank               rank();    
    virtual ExploitabilityRating            CheckPlatformExploitability();


private:

    
    bool canFaultingInstructionNotBeDisassebled();
    bool DoesStackTraceContainUnknownFunctions();
    bool IsEventNotAnException();
    bool IsFaultingAddressInstructionPointer();
    bool IsFaultingInstructionBlockDataMove();
    bool IsFaultingInstructionControlFlow();
    bool IsFaultingInstructionInUserland();
    bool IsFaultingInstructionOnStack();
    bool IsTaintedDataUsedAsAFunctionArgument();
    bool IsTaintedDataUsedAsAFunctionRetVal();
    bool IsTaintedDataUsedAsSourceForBlockDataMove();
    bool IsTaintedDataUsedInALaterWrite();
    bool IsTaintedDataUsedToDetermineBranchSelection();
    bool IsTaintedDataUsedToDetermineBranchTarget();
    bool WasApplicationVerifierStopDetected();
    bool WasBugCheckDetected();
    bool WasExceptionHandlerChainCorrupted();


    ExceptionType       exceptionType();
    ExceptionSubtype    exceptionSubtype();
    BangRule                processRules();



};





} // namespace

#endif