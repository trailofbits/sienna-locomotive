// XXX_INCLUDE_TOB_COPYRIGHT_HERE
//
// Reimplementation of Microsoft's !exploitable using Google's breakpad minidump processing.  The taint functionality is not
// implemented since it's taken care of in tracer.cpp . Does not actually need windbag installed.


#ifndef XploitabilityBangExploitable_H
#define XploitabilityBangExploitable_H

#include "Xploitability.h"
#include <functional>
#include <string>
#include <sstream>

using namespace std;


namespace sl2 {


#define DONT_CARE   0

/*! Tracks whether we're in userland or kernelland */
enum ProcessorMode {
    DONT_CARE_PROCESSOR_MODE = DONT_CARE,
    KERNEL,
    USER
};

/*! Helps us build rules for recognizing different memory ranges*/
enum ExceptionAddressRange {
    /*! We don't care what the address is */
    DONT_CARE_EXCEPTION_ADDRESS_RANGE = DONT_CARE,
    /*! Address is in kernel-land */
    IN_KERNEL_MEMORY,
    /*! Address is in userspace */
    IN_USER_MEMORY,
    /*! Address is suspiciously small */
    NEAR_NULL,
    /*! Address is normal-looking */
    NOT_NEAR_NULL
};

/*! Helps us build rules for recognizing different types of exceptions */
enum ExceptionType {
    /*! Catch-all */
    DONT_CARE_EXCEPTION_TYPE = DONT_CARE,
    /*! Out-of-bounds read or write*/
    STATUS_ACCESS_VIOLATION,
    /*! Debugger breakpoint (could mean we're executing non-instructions) */
    STATUS_BREAKPOINT,
    /*! Division by zero */
    STATUS_FLOAT_DIVIDE_BY_ZERO,
    /*! One-time indication that we've tried to access protected memory */
    STATUS_GUARD_PAGE_VIOLATION,
    /*! Something went wrong on the heap, but it might have taken a long time to fire */
    STATUS_HEAP_CORRUPTION,
    /*! Tried to execute a non-instruction */
    STATUS_ILLEGAL_INSTRUCTION,
    /*! Division by zero */
    STATUS_INTEGER_DIVIDE_BY_ZERO,
    /*! Tried to execute an instruction not allowed in the current processor mode */
    STATUS_PRIVILEGED_INSTRUCTION,
    /*! A buffer overflow on the stack */
    STATUS_STACK_BUFFER_OVERRUN,
    /*! Recursed too many levels deep */
    STATUS_STACK_OVERFLOW,
    /*! More debugging */
    STATUS_WAKE_SYSTEM_DEBUGGER,
    /*! More debugging */
    STATUS_WX86_BREAKPOINT,
    /*! Exceptions that don't tell us much about exploitability */
    STATUS_UNKNOWN
};

/*! Subtypes for differentiating various types of memory access violations */
enum ExceptionSubtype {
    /*! Any memory exception */
    DONT_CARE_EXCEPTION_SUBTYPE = DONT_CARE,
    /*! Tried to execute non-executable memory */
    ACCESS_VIOLATION_TYPE_DEP,
    /*! Tried to read non-readable memory */
    ACCESS_VIOLATION_TYPE_READ,
    /*! Tried to write non-writable memory */
    ACCESS_VIOLATION_TYPE_WRITE
};


/*! Differentiates exception depths */
enum ExceptionLevel {
    DONT_CARE_EXCEPTION_LEVEL = DONT_CARE,
    FIRST_CHANCE,
    SECOND_CHANCE
};


/*! Different analysis results we can output */
enum ResultClassification {
    EXPLOITABLE,
    NOT_AN_EXCEPTION,
    NOT_LIKELY_EXPLOITABLE,
    PROBABLY_EXPLOITABLE,
    UNKNOWN
};



typedef   function<bool()>     AnalyzeFunction;
/**
 * Used to store a set of characteristics that describe a particualr exception that we can then pattern-match against
 */
class BangRule {
public:    
    ProcessorMode           processorMode;              // 1
    ExceptionAddressRange   exceptionAddressRange;      // 2
    ExceptionType           exceptionType;              // 3
    ExceptionSubtype        exceptionSubtype;           // 4
    ExceptionLevel          exceptionLevel;             // 5
    AnalyzeFunction         analyzeFunction;            // 6
    /*! The final result that describes how exploitable the exception described by parameters 1-6 is likely to be */
    ResultClassification    resultClassification;       // 7
    string                  resultDescription;          // 8
    string                  resultDescriptonShort;      // 9
    string                  resultExplaination;         // 10
    bool                    isFinal;                    // 11

    string                  toString() {
        ostringstream stream;
        stream << this;
        return stream.str();
    };


    friend string operator~( const BangRule& self ) {
        return self.resultDescriptonShort;
    }  

    friend ostream& operator<<( ostream& os, const BangRule& self ) {
        os << self.resultDescriptonShort;
        return os;
    }

};






////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// XploitabilityBangExploitable()
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class XploitabilityBangExploitable : public Xploitability {
public:
    
    XploitabilityBangExploitable( Minidump* dmp, ProcessState* state );

    virtual XploitabilityResult                 process();


private:

    BangRule                processRules();
    ExceptionSubtype        exceptionSubtype();
    ExceptionType           exceptionType();
    const bool              WasApplicationVerifierStopDetected()            const;
    const bool              WasBugCheckDetected()                           const;
    const bool              WasExceptionHandlerChainCorrupted()             const;
    const bool              canFaultingInstructionNotBeDisassebled()        const;
    const bool              doesStackTraceContainUnknownFunctions()         const;
    const bool              isEventNotAnException()                         const;
    const bool              isFaultingAddressInstructionPointer()           const;
    const bool              isFaultingInstructionBlockDataMove()            const;
    const bool              isFaultingInstructionControlFlow()              const;
    const bool              isFaultingInstructionInUserland()               const;
    const bool              isFaultingInstructionOnStack()                  const;
    const bool              isTaintedDataUsedAsAFunctionArgument()          const;
    const bool              isTaintedDataUsedAsAFunctionRetVal()            const;
    const bool              isTaintedDataUsedAsSourceForBlockDataMove()     const;
    const bool              isTaintedDataUsedInALaterWrite()                const;
    const bool              isTaintedDataUsedToDetermineBranchSelection()   const;
    const bool              isTaintedDataUsedToDetermineBranchTarget()      const;

};

} // namespace

#endif