#include "Xploitability.h"
#include "XploitabilityBangExploitable.h"
#include "google_breakpad/common/minidump_exception_win32.h"
#include "processor/disassembler_x86.h"

#include <functional>

#include <cstdlib>

using namespace std;

namespace sl2 {

XploitabilityBangExploitable::XploitabilityBangExploitable(Minidump *dump,
        ProcessState *process_state)
        : Xploitability(dump, process_state) {
    CheckPlatformExploitability();
}

////////////////////////////////////////////////////////////////////////////
// canFaultingInstructionNotBeDisassebled()
//      Returns true we can disassemble at pc
bool XploitabilityBangExploitable::canFaultingInstructionNotBeDisassebled() { 

    if(!memoryAvailable_)
        return false;
    

    size_t bufsz = 20;
    MinidumpMemoryRegion* instrRegion =
        memoryList_->GetMemoryRegionForAddress(instructionPtr_);


     const uint8_t *rawMem =
                instrRegion->GetMemory() + bufsz;

    DisassemblerX86 disassembler(rawMem, bufsz,  instructionPtr_);
    return disassembler.currentInstructionValid();
}

bool XploitabilityBangExploitable::DoesStackTraceContainUnknownFunctions()  { return false; }
////////////////////////////////////////////////////////////////////////////

bool XploitabilityBangExploitable::IsEventNotAnException() { return false; }

////////////////////////////////////////////////////////////////////////////
bool XploitabilityBangExploitable::IsFaultingAddressInstructionPointer() { return false; }
////////////////////////////////////////////////////////////////////////////

bool XploitabilityBangExploitable::IsFaultingInstructionBlockDataMove() { return false; }
bool XploitabilityBangExploitable::IsFaultingInstructionControlFlow() { return false; }
bool XploitabilityBangExploitable::IsFaultingInstructionInUserland() { return false; }

////////////////////////////////////////////////////////////////////////////
bool XploitabilityBangExploitable::IsFaultingInstructionOnStack() {
    uint64_t addy = process_state_->crash_address();
    uint64_t delta = abs( (int64_t)(addy - stackPtr_) );

    if( delta<40960 ) {
        return true;
    }
    return false;
}



bool XploitabilityBangExploitable::IsTaintedDataUsedAsAFunctionArgument() { return false; }
bool XploitabilityBangExploitable::IsTaintedDataUsedAsAFunctionRetVal() { return false; }
bool XploitabilityBangExploitable::IsTaintedDataUsedAsSourceForBlockDataMove() { return false; }
bool XploitabilityBangExploitable::IsTaintedDataUsedInALaterWrite() { return false; }
bool XploitabilityBangExploitable::IsTaintedDataUsedToDetermineBranchSelection() { return false; }
bool XploitabilityBangExploitable::IsTaintedDataUsedToDetermineBranchTarget() { return false; }
bool XploitabilityBangExploitable::WasApplicationVerifierStopDetected() { return false; }
bool XploitabilityBangExploitable::WasBugCheckDetected() { return false; }
bool XploitabilityBangExploitable::WasExceptionHandlerChainCorrupted() { return false; }



XploitabilityRank XploitabilityBangExploitable::rank() {
    return rank_;
}



ExceptionType XploitabilityBangExploitable::exceptionType() {

    switch(exceptionCode_) {
        case MD_EXCEPTION_CODE_WIN_CONTROL_C:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_GUARD_PAGE_VIOLATION:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_DATATYPE_MISALIGNMENT:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_BREAKPOINT:
                return STATUS_BREAKPOINT;
        case MD_EXCEPTION_CODE_WIN_SINGLE_STEP:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_ACCESS_VIOLATION:
                return STATUS_ACCESS_VIOLATION;
        case MD_EXCEPTION_CODE_WIN_IN_PAGE_ERROR:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_INVALID_HANDLE:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_ILLEGAL_INSTRUCTION:
                return STATUS_ILLEGAL_INSTRUCTION;
        case MD_EXCEPTION_CODE_WIN_NONCONTINUABLE_EXCEPTION:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_INVALID_DISPOSITION:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_ARRAY_BOUNDS_EXCEEDED:
                return STATUS_ACCESS_VIOLATION;
        case MD_EXCEPTION_CODE_WIN_FLOAT_DENORMAL_OPERAND:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_FLOAT_DIVIDE_BY_ZERO:
                return STATUS_FLOAT_DIVIDE_BY_ZERO;
        case MD_EXCEPTION_CODE_WIN_FLOAT_INEXACT_RESULT:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_FLOAT_INVALID_OPERATION:
                return STATUS_ILLEGAL_INSTRUCTION;
        case MD_EXCEPTION_CODE_WIN_FLOAT_OVERFLOW:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_FLOAT_STACK_CHECK:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_FLOAT_UNDERFLOW:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_INTEGER_DIVIDE_BY_ZERO:
                return STATUS_INTEGER_DIVIDE_BY_ZERO;
        case MD_EXCEPTION_CODE_WIN_INTEGER_OVERFLOW:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_PRIVILEGED_INSTRUCTION:
                return STATUS_PRIVILEGED_INSTRUCTION;
        case MD_EXCEPTION_CODE_WIN_STACK_OVERFLOW:
                return STATUS_STACK_OVERFLOW;
        case MD_EXCEPTION_CODE_WIN_BAD_FUNCTION_TABLE:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_POSSIBLE_DEADLOCK:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_STACK_BUFFER_OVERRUN:
                return STATUS_STACK_BUFFER_OVERRUN;
        case MD_EXCEPTION_CODE_WIN_HEAP_CORRUPTION:
                return STATUS_HEAP_CORRUPTION;
        case MD_EXCEPTION_OUT_OF_MEMORY:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_UNHANDLED_CPP_EXCEPTION:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_SIMULATED:
                return STATUS_UNKNOWN;
        default:
                return STATUS_UNKNOWN;
    }

}

ExceptionSubtype XploitabilityBangExploitable::exceptionSubtype() {

    if( rawException_->exception_record.number_parameters < 1)
        return DONT_CARE_EXCEPTION_SUBTYPE;

    auto avType = static_cast<MDAccessViolationTypeWin>
        (rawException_->exception_record.exception_information[0]);

    switch (avType) {
        case MD_ACCESS_VIOLATION_WIN_READ:
            return ACCESS_VIOLATION_TYPE_READ;
        case MD_ACCESS_VIOLATION_WIN_WRITE:
            return ACCESS_VIOLATION_TYPE_WRITE;
        case MD_ACCESS_VIOLATION_WIN_EXEC:
            return ACCESS_VIOLATION_TYPE_DEP;
        default:
            return DONT_CARE_EXCEPTION_SUBTYPE;
    }

}

BangRule XploitabilityBangExploitable::processRules() {
    vector<BangRule> rules = {
	// Gather and report the initial state of the debugger
	//
	// Note that we don't report the stack information here, because we may gather it multiple times as we find
	// better contexts within which to work. Because of this, stack information is actually reported by the rules
	// engine itself
	// Rule: If the event in the debugger is not an exception, we are unable to continue any further with our
	//		 analysis, and we terminate   

    
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            DONT_CARE_EXCEPTION_TYPE,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,        
            bind( &XploitabilityBangExploitable::IsEventNotAnException, this ),
            NOT_AN_EXCEPTION,
            "",
            "NotException",
            "The current event is not an exception. No further analysis will be done.",
            true,
        },


        // Rule: If the exception is a Debugger Wake event, no further processing is necessary, something unusual has happened,
        //       we don't know what, and we don't have any way to get additional data
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_WAKE_SYSTEM_DEBUGGER,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            UNKNOWN,
            "",
            "DebuggerWakeEvent",
            "The application has requested a Debugger Wake event. This should not happen during normal operations, and should be investigated.",

            true,
        },

        // Rule: Any exception in which the faulting instruction is executing from the stack is exploitable
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            DONT_CARE_EXCEPTION_TYPE,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::IsFaultingInstructionOnStack, this ),
            EXPLOITABLE,
            "Exception generated by code running in the Stack",
            "StackCodeExecution",
            "Code execution from the stack is considered exploitable",

            true,
        },

        // Rule: Any exception in kernel mode where the faulting instruction is executing from user space is exploitable
        {
            KERNEL,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            DONT_CARE_EXCEPTION_TYPE,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::IsFaultingInstructionInUserland, this ),
            EXPLOITABLE,
            "Kernel Exception in Userland",
            "KernelExceptionInUserland",
            "Any exception occurring in kernel mode where the code is in Userland is considered exploitable",

            true,
        },

        // Rule: Illegal instruction exceptions indicate that program flow has been controlled by an attacker
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ILLEGAL_INSTRUCTION,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Illegal Instruction Violation",
            "IllegalInstruction",
            "An illegal instruction exception indicates that the attacker controls execution flow.",

            true,
        },

        // Rule: Privileged  instruction exceptions indicate that program flow has been controlled by an attacker
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_PRIVILEGED_INSTRUCTION,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Privileged Instruction Violation",
            "PrivilegedInstruction",
            "A privileged instruction exception indicates that the attacker controls execution flow.",

            true,
        },

        // Rule: All Guard Page exceptions must be fixed
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_GUARD_PAGE_VIOLATION,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Guard Page Violation",
            "GuardPage",
            "",

            true,
        },

        // Rule: Stack Buffer Overruns (/GS Exceptions) must be fixed
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_STACK_BUFFER_OVERRUN,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Stack Buffer Overrun (/GS Exception)",
            "GSViolation",
            "An overrun of a protected stack buffer has been detected. This is considered exploitable, and must be fixed.",

            true,
        },

        // Rule: Heap Corruption is considered exploitable
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_HEAP_CORRUPTION,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Heap Corruption",
            "HeapCorruption",
            "Heap Corruption has been detected. This is considered exploitable, and must be fixed.",

            true,
        },

        // Rule: All DEP violations in kernal mode are exploitable
        {
            KERNEL,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_DEP,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Kernel Mode Data Execution Prevention Violation",
            "DEPViolation",
            "All kernel mode DEP access violations are exploitable.",

            true,
        },

        // Rule: DEP violations in user mode are exploitable if not near null
        {
            USER,
            NOT_NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_DEP,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Data Execution Prevention Violation",
            "DEPViolation",
            "User mode DEP access violations are exploitable.",

            true,
        },

        // Rule: AVs at the instruction pointer are exploitable if in kernel mode
        {
            KERNEL,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::IsFaultingAddressInstructionPointer, this ),
            EXPLOITABLE,
            "Kernel Mode Read Access Violation at the Instruction Pointer",
            "ReadAVonIP",
            "All kernel access violations at the instruction pointer are exploitable.",

            true,
        },

        // Rule: AVs at the instruction pointer are exploitable if not near null in user mode
        {
            USER,
            NOT_NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::IsFaultingAddressInstructionPointer, this ),
            EXPLOITABLE,
            "Read Access Violation at the Instruction Pointer",
            "ReadAVonIP",
            "Access violations at the instruction pointer are exploitable if not near NULL.",

            true,
        },


        // Rule: Corrupted exception handler chains are always exploitable
        {
            USER,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            DONT_CARE_EXCEPTION_TYPE,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::WasExceptionHandlerChainCorrupted, this ),
            EXPLOITABLE,
            "Exception Handler Chain Corrupted",
            "ExceptionHandlerCorrupted",
            "Corruption of the exception handler chain is considered exploitable",

            true,
        },

        // Rule: DEP violations in user mode are probably exploitable if near null
        {
            USER,
            NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_DEP,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            PROBABLY_EXPLOITABLE,
            "Data Execution Prevention Violation near NUL",
            "DEPViolation",
            "User mode DEP access violations are probably exploitable if near NULL.",

            true,
        },

        // Rule: AVs at the instruction pointer are probably exploitable if near null in user mode
        {
            USER,
            NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::IsFaultingAddressInstructionPointer, this ),
            PROBABLY_EXPLOITABLE,
            "Read Access Violation Near Null at the Instruction Pointer",
            "ReadAVonIP",
            "Access violations at the instruction pointer are probably exploitable if near NULL.",

            true,
        },



        // Rule: check if the instruction pointer can be un assembled if not, execution is way off.
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::canFaultingInstructionNotBeDisassebled, this ),
            PROBABLY_EXPLOITABLE,
            "Cannot disassemble instruction",
            "ReadAvOnIP",
            "There is no memory backing the instruction pointer. Disassembly of instruction failed.",

            true,
        },



        // Rule: All user mode Write Access violations are exploitable if not near null
        {
            USER,
            NOT_NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_WRITE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "User Mode Write AV",
            "WriteAV",
            "User mode write access violations that are not near NULL are exploitable.",

            true,
        },



        // Rule: Kernel mode first chance write exceptions are exploitable if the address is in kernel memory
        {
            KERNEL,
            IN_KERNEL_MEMORY,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_WRITE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Write Access Violation in Kernel Memory",
            "WriteAV",
            "All kernel mode write access violations in kernel memory are exploitable.",

            true,
        },

        // Rule: Kernel mode second chance write exceptions are exploitable
        {
            KERNEL,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_WRITE,
            SECOND_CHANCE,
            nullptr,
            EXPLOITABLE,
            "Write Access Violation in Kernel Mode",
            "WriteAV",
            "All kernel mode second chance write access violations are exploitable.",

            true,
        },

        // Rule: AVs on control flow are considered exploitable in the kernel
        {
            KERNEL,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::IsFaultingInstructionControlFlow, this ),
            EXPLOITABLE,
            "Kernel Read Access Violation on Control Flow",
            "ReadAVonControlFlow",
            "All kernel access violations in control flow instructions are considered exploitable.",

            true,
        },

        // Rule: AVs on control flow are considered exploitable in user mode if not near null
        {
            USER,
            NOT_NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::IsFaultingInstructionControlFlow, this ),
            EXPLOITABLE,
            "Read Access Violation on Control Flow",
            "ReadAVonControlFlow",
            "Access violations not near null in control flow instructions are considered exploitable.",

            true,
        },

        // Rule: AVs on control flow are considered probably exploitable in user mode if near null
        {
            USER,
            NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::IsFaultingInstructionControlFlow, this ),
            PROBABLY_EXPLOITABLE,
            "Read Access Violation on Control Flow",
            "ReadAVonControlFlow",
            "Access violations near null in control flow instructions are considered probably exploitable.",

            true,
        },

        // Rule: Read AVS in a block move are considered probably exploitable
        {
            USER,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::IsFaultingInstructionBlockDataMove, this ),
            PROBABLY_EXPLOITABLE,
            "Read Access Violation on Block Data Move",
            "ReadAVonBlockMove",
            "This is a read access violation in a block data move, and is therefore classified as probably exploitable.",

            true,
        },

        // Rule: Read AVS in a block move are considered probably exploitable
        {
            KERNEL,
            IN_KERNEL_MEMORY,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::IsFaultingInstructionBlockDataMove, this ),
            PROBABLY_EXPLOITABLE,
            "Kernel Memory Read Access Violation on Block Data Move",
            "ReadAVonBlockMove",
            "This is a read access violation in a kernel memory block data move, and is therefore classified as probably exploitable.",

            true,
        },

        // Rule: Read AVS in a block move are considered probably exploitable
        {
            KERNEL,
            IN_USER_MEMORY,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            SECOND_CHANCE,
            bind( &XploitabilityBangExploitable::IsFaultingInstructionBlockDataMove, this ),
            PROBABLY_EXPLOITABLE,
            "Memory Read Access Violation on Block Data Move",
            "ReadAVonBlockMove",
            "This is a second chance read access violation in a kernel mode block data move, and is therefore classified as probably exploitable.",

            true,
        },


        // Rule: Tainted information used to control branch addresses is considered probably exploitable
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::IsTaintedDataUsedToDetermineBranchTarget, this ),
            PROBABLY_EXPLOITABLE,
            "Data from Faulting Address controls Code Flow",
            "TaintedDataControlsCodeFlow",
            "The data from the faulting address is later used as the target for a branch.",

            true,
        },

        // Rule: Tainted information used to control the target of a later write is probably exploitable
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::IsTaintedDataUsedInALaterWrite, this ),
            PROBABLY_EXPLOITABLE,
            "Data from Faulting Address controls subsequent Write Address",
            "TaintedDataControlsWriteAddress",
            "The data from the faulting address is later used as the target for a later write.",

            true,
        },


        // Rule: Application Verifier Stops are called out as unknown
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            DONT_CARE_EXCEPTION_TYPE,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::WasApplicationVerifierStopDetected, this ),
            UNKNOWN,
            "Application Verifier Stop",
            "AppVerifierStop",
            "An Application Verifier Stop was detected, but no additional security details could be determined. This fault must be manually investigated.",

            true,
        },


        //
        // Probably Not Exploitable Terminal Rules
        //
        // These are rules where further analysis has shown that it isn't worth human evaluation, even if there
        // are other mitigating circumstances
        //

        // Rule: User Mode Read AVs near null are considered probably not exploitable
        {
            USER,
            NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            NOT_LIKELY_EXPLOITABLE,
            "Read Access Violation near NUL",
            "ReadAVNearNull",
            "This is a user mode read access violation near null, and is probably not exploitable.",

            true,
        },

        //
        // All non-final rules should be evaulated here. Please note that execution order is very important,
        // as each successive rule could override a previous rules results
        //

        // 
        // Probably Not Exploitable Non-Terminal Rules
        //

        // Rule: First chance read AVs from user memory in the kernel are not considered exploitable
        {
            KERNEL,
            IN_USER_MEMORY,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            FIRST_CHANCE,
            nullptr,
            NOT_LIKELY_EXPLOITABLE,
            "First Chance Kernel Read Access Violation in User Memory",
            "ReadAV",
            "This is a kernel mode first chance read access violation in user memory, and is probably not exploitable.",

            false,
        },

        // Rule: First chance write AVs from user memory in the kernel are not considered exploitable
        {
            KERNEL,
            IN_USER_MEMORY,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_WRITE,
            FIRST_CHANCE,
            nullptr,
            NOT_LIKELY_EXPLOITABLE,
            "First Chance Kernel Write Access Violation in User Memory",
            "WriteAV",
            "This is a kernel mode first chance write access violation in user memory, and is probably not exploitable.",

            false,
        },

        // Rule: Divide By Zero is not considered exploitable
        {
            USER,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_INTEGER_DIVIDE_BY_ZERO,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            NOT_LIKELY_EXPLOITABLE,
            "Integer Divide By Zero",
            "DivideByZero",
            "This is a divide by zero, and is probably not exploitable.",

            false,
        },

        // Rule: Divide By Zero is not considered exploitable
        {
            USER,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_FLOAT_DIVIDE_BY_ZERO,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            NOT_LIKELY_EXPLOITABLE,
            "Float Divide By Zero",
            "DivideByZero",
            "This is a divide by zero, and is probably not exploitable.",

            false,
        },

        // Rule: Stack exhaustion is not considered exploitable
        {
            USER,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_STACK_OVERFLOW,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            NOT_LIKELY_EXPLOITABLE,
            "Stack Exhaustion",
            "StackExhaustion",
            "Stack Exhaustion is considered to be probably not exploitable.",

            false,
        },

        //
        // Unknown Exploitability Non-Terminal Rules
        //

        // Rule: All user mode Write Access violations are UNKNOWN if near null
        {
            USER,
            NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_WRITE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            UNKNOWN,
            "User Mode Write AV near NUL",
            "WriteAVNearNull",
            "User mode write access violations that are near NULL are unknown.",

            false,
        },

        // Rule: Breakpoints are considered probably not exploitable, but should not occur in production code
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_WX86_BREAKPOINT,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            UNKNOWN,
            "Breakpoint",
            "Breakpoint",
            "While a breakpoint itself is probably not exploitable, it may also be an indication that an attacker is testing a target. In either case breakpoints should not exist in production code.",

            false,
        },

        // Rule: Breakpoints are considered probably not exploitable, but should not occur in production code
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_BREAKPOINT,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            UNKNOWN,
            "Breakpoint",
            "Breakpoint",
            "While a breakpoint itself is probably not exploitable, it may also be an indication that an attacker is testing a target. In either case breakpoints should not exist in production code.",

            false,
        },

        // Rule: Bug checks that we don't have special case handling for should be called out separately
        {
            KERNEL,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_BREAKPOINT,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::WasBugCheckDetected, this ),
            UNKNOWN,
            "BugCheck",
            "BugCheck",
            "A BugCheck was detected, but no further information about the severity could be determined.",

            false,
        },

        // Rule: If the stack contains unknown symbols in user mode, call that out
        {
            USER,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            DONT_CARE_EXCEPTION_TYPE,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::DoesStackTraceContainUnknownFunctions, this ),
            UNKNOWN,
            "Possible Stack Corruption",
            "PossibleStackCorruption",
            "The stack trace contains one or more locations for which no symbol or module could be found. This may be a sign of stack corruption.",

            false,
        },

        // Rule: Kernel Mode Read AVs near NULL are considered to have an unknown exploitability
        {
            KERNEL,
            NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            UNKNOWN,
            "Kernel Read Access Violation near NUL",
            "ReadAVNearNull",
            "This is a kernel mode read access violation near null.",

            false,
        },

        // Rule: Tainted information used to control the source of a later block move unknown, but called out explicitly
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::IsTaintedDataUsedAsSourceForBlockDataMove, this ),
            UNKNOWN,
            "Data from Faulting Address is used in a subsequent Block Data Move",
            "TaintedDataUsedInBlockMove",
            "The data from the faulting address is later used as the input for a later block data move.",

            false,
        },

        // Rule: First Chance Read AVS in a block move in the kernel are called out as unknown
        {
            KERNEL,
            IN_USER_MEMORY,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            FIRST_CHANCE,
            bind( &XploitabilityBangExploitable::IsFaultingInstructionBlockDataMove, this ),
            UNKNOWN,
            "Memory Read Access Violation on Block Data Move",
            "ReadAVonBlockMove",
            "This is a first chance read access violation in a kernel mode block data move. If the attacker controls the size of the move, this may represent a security issue.",

            false,
        },

        // Rule: Tainted information used as an argument to a function is an unknown risk, but called out explicitly
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::IsTaintedDataUsedAsAFunctionArgument, this ),
            UNKNOWN,
            "Data from Faulting Address is used as one or more arguments in a subsequent Function Call",
            "TaintedDataPassedToFunction",
            "The data from the faulting address is later used as one or more of the arguments to a function call.",

            false,
        },

        // Rule: Tainted information returned from a function is an unknown risk, but called out explicitly
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::IsTaintedDataUsedAsAFunctionRetVal, this ),
            UNKNOWN,
            "Data from Faulting Address may be used as a return value",
            "TaintedDataReturnedFromFunction",
            "The data from the faulting address may later be used as a return value from this function.",

            false,
        },



        // Rule: Tainted information used to control branch selection is an unknown risk, but called out explicitly
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::IsTaintedDataUsedToDetermineBranchSelection, this ),
            UNKNOWN,
            "Data from Faulting Address controls Branch Selection",
            "TaintedDataControlsBranchSelection",
            "The data from the faulting address is later used to determine whether or not a branch is taken.",

            false,
        }
    
    };


    for( BangRule& rule : rules ) {
        cout << "!x: " << rule.resultDescriptonShort  << endl;
        // We are ignoring anything in kernel mode
        if( rule.processorMode==KERNEL ) {
            continue;
        }
        
        if( ( rule.exceptionAddressRange != DONT_CARE_EXCEPTION_ADDRESS_RANGE ) 
            && 
                ( ((rule.exceptionAddressRange == IN_KERNEL_MEMORY) 
                    && isExceptionAddressInUser()) ||
                ( (rule.exceptionAddressRange  == IN_USER_MEMORY) 
                    && !isExceptionAddressInUser()) ||
                ( (rule.exceptionAddressRange  == NEAR_NULL) 
                    && !isExceptionAddressNearNull()) ||
                ( (rule.exceptionAddressRange  == NOT_NEAR_NULL) 
                && isExceptionAddressNearNull()) ) ) {
            continue;
        }

        if( rule.exceptionType != DONT_CARE_EXCEPTION_TYPE) {            
            if( rule.exceptionType != exceptionType()  )  {
                continue;
            }
        }

        if( (rule.exceptionSubtype != DONT_CARE_EXCEPTION_SUBTYPE ) && 
                rule.exceptionSubtype != exceptionSubtype() ) {
            continue;
        }

        // No exception level handling here since I believe it's only applicable to 
        // kernel mode which we aren't dealing with anyways.  

        // Make sure we have a method than analyzes
        if( rule.analyzeFunction ) {
            if( !rule.analyzeFunction() ) {
                continue;
            }
        }

        if( !rule.isFinal ) {
            continue;
        }

        return rule;
    }

    // Couldn't find anything
    return BangRule  {        
        DONT_CARE_PROCESSOR_MODE,
        DONT_CARE_EXCEPTION_ADDRESS_RANGE,
        DONT_CARE_EXCEPTION_TYPE,
        DONT_CARE_EXCEPTION_SUBTYPE,
        DONT_CARE_EXCEPTION_LEVEL,        
        nullptr,
        UNKNOWN,
        "Unknown",
        "Unknown",
        "Nothing matched",
        true,
    };

    
}

ExploitabilityRating XploitabilityBangExploitable::CheckPlatformExploitability() {
    
    BangRule& rule = processRules();

    cout << "!x Final: " << rule << endl;    
    return EXPLOITABILITY_NOT_ANALYZED;
}




} // namespace