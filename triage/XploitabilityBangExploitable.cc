// XXX_INCLUDE_TOB_COPYRIGHT_HERE
//
// Reimplementation of Microsoft's !exploitable using Google's breakpad minidump processing.  The taint functionality is not
// implemented since it's taken care of in tracer.cpp . Does not actually need windbag installed.

#include "Xploitability.h"
#include "XploitabilityBangExploitable.h"
#include "google_breakpad/common/minidump_exception_win32.h"
#include <cstdlib>
#include <functional>
#include <unordered_set>

using namespace std;

namespace sl2 {

/**
 * XploitabilityBangExploitable
 * @param dump
 * @param process_state
 */
XploitabilityBangExploitable::XploitabilityBangExploitable(Minidump *dump,
        ProcessState *process_state)
        : Xploitability(dump, process_state, "!exploitable") {
}

/**
 * @return false if we can disassemble at pc
 */
const bool XploitabilityBangExploitable::canFaultingInstructionNotBeDisassebled() const { 

    if(!memoryAvailable_)
        return false;
    if(!disassembler_)
        return false;    
    
    return !disassembler_->currentInstructionValid();
    
}

/**
 * This information isn't easily available in breakpad
 */
const bool XploitabilityBangExploitable::doesStackTraceContainUnknownFunctions() const { 
    return false; 
}

/**
 * Checks exceptionCode_ against all possible valid windows exception
 * @return whether we found the exception code
 */
const bool XploitabilityBangExploitable::isEventNotAnException() const { 
    unordered_set<MDExceptionCodeWin> validExceptions = {
        MD_EXCEPTION_CODE_WIN_CONTROL_C,
        MD_EXCEPTION_CODE_WIN_GUARD_PAGE_VIOLATION,
        MD_EXCEPTION_CODE_WIN_ACCESS_VIOLATION,
        MD_EXCEPTION_CODE_WIN_ARRAY_BOUNDS_EXCEEDED,
        MD_EXCEPTION_CODE_WIN_BAD_FUNCTION_TABLE,
        MD_EXCEPTION_CODE_WIN_BREAKPOINT,
        MD_EXCEPTION_CODE_WIN_DATATYPE_MISALIGNMENT,
        MD_EXCEPTION_CODE_WIN_FLOAT_DENORMAL_OPERAND,
        MD_EXCEPTION_CODE_WIN_FLOAT_DIVIDE_BY_ZERO,
        MD_EXCEPTION_CODE_WIN_FLOAT_INEXACT_RESULT,
        MD_EXCEPTION_CODE_WIN_FLOAT_INVALID_OPERATION,
        MD_EXCEPTION_CODE_WIN_FLOAT_OVERFLOW,
        MD_EXCEPTION_CODE_WIN_FLOAT_STACK_CHECK,
        MD_EXCEPTION_CODE_WIN_FLOAT_UNDERFLOW,
        MD_EXCEPTION_CODE_WIN_HEAP_CORRUPTION,
        MD_EXCEPTION_CODE_WIN_ILLEGAL_INSTRUCTION,
        MD_EXCEPTION_CODE_WIN_INTEGER_DIVIDE_BY_ZERO,
        MD_EXCEPTION_CODE_WIN_INTEGER_OVERFLOW,
        MD_EXCEPTION_CODE_WIN_INVALID_DISPOSITION,
        MD_EXCEPTION_CODE_WIN_INVALID_HANDLE,
        MD_EXCEPTION_CODE_WIN_IN_PAGE_ERROR,
        MD_EXCEPTION_CODE_WIN_NONCONTINUABLE_EXCEPTION,
        MD_EXCEPTION_CODE_WIN_POSSIBLE_DEADLOCK,
        MD_EXCEPTION_CODE_WIN_PRIVILEGED_INSTRUCTION,
        MD_EXCEPTION_CODE_WIN_SINGLE_STEP,
        MD_EXCEPTION_CODE_WIN_STACK_BUFFER_OVERRUN,
        MD_EXCEPTION_CODE_WIN_STACK_OVERFLOW,
        MD_EXCEPTION_OUT_OF_MEMORY
    };

    for( auto exc : validExceptions ) {
        if( exc==exceptionCode_ ) {
            return false;
        }
    }
    return true;
}

/**
 * @return true if pc is the crashing memory address
 */
const bool XploitabilityBangExploitable::isFaultingAddressInstructionPointer() const { 
    return instructionPtr_ == process_state_->crash_address();
}

/**
 * They call a "block data move" a move with a rep (on x86)
 */
const bool XploitabilityBangExploitable::isFaultingInstructionBlockDataMove() const { 
    if(!disassembler_)
        return false;
    auto instr = disassembler_->currentInstruction();
    if( nullptr == instr )
        return false;

    auto group = disassembler_->currentInstructionGroup() ;
    return group == libdis::insn_move &&    
            (
                (instr->prefix & libdis::insn_rep_zero) ||
                (instr->prefix & libdis::insn_rep_notzero)
            );        
}

/**
 * @return True if faulting instruction is a control flow instruction
 */
const bool XploitabilityBangExploitable::isFaultingInstructionControlFlow() const { 
    if(!disassembler_)
        return false;
    auto instr = disassembler_->currentInstruction();
    if( nullptr == instr )
        return false;

    auto group = disassembler_->currentInstructionGroup() ;

    return group == libdis::insn_controlflow; 
}

/**
 * @return True if instruction is in userland (64bit only)
 */
const bool XploitabilityBangExploitable::isFaultingInstructionInUserland() const { 
    return instructionPtr_ <= 0x7fffffffffffffff;    
}

/**
 * @return whether the instruction pointer is near the stack
 */
const bool XploitabilityBangExploitable::isFaultingInstructionOnStack()const {
    uint64_t delta = abs( (int64_t)(instructionPtr_ - stackPtr_) );

    if( delta<40960 ) {
        return true;
    }
    return false;
}


/**
 * Taint functionality is implemented in XploitabilityTracer.cc
 */
const bool XploitabilityBangExploitable::isTaintedDataUsedAsAFunctionArgument() const { return false; }

/**
 * Taint functionality is implemented in XploitabilityTracer.cc
 */
const bool XploitabilityBangExploitable::isTaintedDataUsedAsAFunctionRetVal() const { return false; }

/**
 * Taint functionality is implemented in XploitabilityTracer.cc
 */
const bool XploitabilityBangExploitable::isTaintedDataUsedAsSourceForBlockDataMove() const { return false; }

/**
 * Taint functionality is implemented in XploitabilityTracer.cc
 */
const bool XploitabilityBangExploitable::isTaintedDataUsedInALaterWrite() const { return false; }

/**
 * Taint functionality is implemented in XploitabilityTracer.cc
 */
const bool XploitabilityBangExploitable::isTaintedDataUsedToDetermineBranchSelection() const { return false; }

/**
 * Taint functionality is implemented in XploitabilityTracer.cc
 */
const bool XploitabilityBangExploitable::isTaintedDataUsedToDetermineBranchTarget() const { return false; }

/**
 *  Not applicable
 */
const bool XploitabilityBangExploitable::WasApplicationVerifierStopDetected() const { return false; }

/**
 * Not applicable for us
 */
const bool XploitabilityBangExploitable::WasBugCheckDetected() const { return false; }

/**
 * Not implemented
 */
const bool XploitabilityBangExploitable::WasExceptionHandlerChainCorrupted() const { return false; }

/**
 * Converts breakpad exceptionCode to !exploitable exception type
 */
ExceptionType XploitabilityBangExploitable::exceptionType() {

    switch(exceptionCode_) {
        case MD_EXCEPTION_CODE_WIN_CONTROL_C:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_GUARD_PAGE_VIOLATION:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_DATATYPE_MISALIGNMENT:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_BREAKPOINT:
                return STATUS_BREAKPOINT;
        case MD_EXCEPTION_CODE_WIN_SINGLE_STEP:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_ACCESS_VIOLATION:
                return STATUS_ACCESS_VIOLATION;
        case MD_EXCEPTION_CODE_WIN_IN_PAGE_ERROR:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_INVALID_HANDLE:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_ILLEGAL_INSTRUCTION:
                return STATUS_ILLEGAL_INSTRUCTION;
        case MD_EXCEPTION_CODE_WIN_NONCONTINUABLE_EXCEPTION:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_INVALID_DISPOSITION:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_ARRAY_BOUNDS_EXCEEDED:
                return STATUS_ACCESS_VIOLATION;
        case MD_EXCEPTION_CODE_WIN_FLOAT_DENORMAL_OPERAND:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_FLOAT_DIVIDE_BY_ZERO:
                return STATUS_FLOAT_DIVIDE_BY_ZERO;
        case MD_EXCEPTION_CODE_WIN_FLOAT_INEXACT_RESULT:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_FLOAT_INVALID_OPERATION:
                return STATUS_ILLEGAL_INSTRUCTION;
        case MD_EXCEPTION_CODE_WIN_FLOAT_OVERFLOW:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_FLOAT_STACK_CHECK:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_FLOAT_UNDERFLOW:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_INTEGER_DIVIDE_BY_ZERO:
                return STATUS_INTEGER_DIVIDE_BY_ZERO;
        case MD_EXCEPTION_CODE_WIN_INTEGER_OVERFLOW:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_PRIVILEGED_INSTRUCTION:
                return STATUS_PRIVILEGED_INSTRUCTION;
        case MD_EXCEPTION_CODE_WIN_STACK_OVERFLOW:
                return STATUS_STACK_OVERFLOW;
        case MD_EXCEPTION_CODE_WIN_BAD_FUNCTION_TABLE:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_POSSIBLE_DEADLOCK:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_STACK_BUFFER_OVERRUN:
                return STATUS_STACK_BUFFER_OVERRUN;
        case MD_EXCEPTION_CODE_WIN_HEAP_CORRUPTION:
                return STATUS_HEAP_CORRUPTION;
        case MD_EXCEPTION_OUT_OF_MEMORY:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_UNHANDLED_CPP_EXCEPTION:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_SIMULATED:
                return STATUS_UNKNOWN;
        default:
                return STATUS_UNKNOWN;
    }

}

/**
 * Converts breakpad to !exploitable subtype
 */
ExceptionSubtype XploitabilityBangExploitable::exceptionSubtype() {

    if( rawException_->exception_record.number_parameters < 1)
        return DONT_CARE_EXCEPTION_SUBTYPE;

    auto avType = static_cast<MDAccessViolationTypeWin>
        (rawException_->exception_record.exception_information[0]);

    switch (avType) {
        case MD_ACCESS_VIOLATION_WIN_READ:
            return ACCESS_VIOLATION_TYPE_READ;
        case MD_ACCESS_VIOLATION_WIN_WRITE:
            return ACCESS_VIOLATION_TYPE_WRITE;
        case MD_ACCESS_VIOLATION_WIN_EXEC:
            return ACCESS_VIOLATION_TYPE_DEP;
        default:
            return DONT_CARE_EXCEPTION_SUBTYPE;
    }
}

/**
 * These is the structure of the rules as implemented for !exploitable
 * The rules are a series of checks that depend on processor mode, exception address,
 * and exception type and subtype.  Analysis functions are called and eventually
 * an exploitability is returned
 * @return rule describing current exception
 */
BangRule XploitabilityBangExploitable::processRules() {

    vector<BangRule> rules = {    
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            DONT_CARE_EXCEPTION_TYPE,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,        
            bind( &XploitabilityBangExploitable::isEventNotAnException, this ),
            NOT_AN_EXCEPTION,
            "",
            "NotException",
            "The current event is not an exception. No further analysis will be done.",
            true,
        },

        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_WAKE_SYSTEM_DEBUGGER,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            UNKNOWN,
            "",
            "DebuggerWakeEvent",
            "The application has requested a Debugger Wake event. This should not happen during normal operations, and should be investigated.",
            true,
        },

        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            DONT_CARE_EXCEPTION_TYPE,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingInstructionOnStack, this ),
            EXPLOITABLE,
            "Exception generated by code running in the Stack",
            "StackCodeExecution",
            "Code execution from the stack is considered exploitable",
            true,
        },

        {
            KERNEL,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            DONT_CARE_EXCEPTION_TYPE,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingInstructionInUserland, this ),
            EXPLOITABLE,
            "Kernel Exception in Userland",
            "KernelExceptionInUserland",
            "Any exception occurring in kernel mode where the code is in Userland is considered exploitable",
            true,
        },

        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ILLEGAL_INSTRUCTION,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Illegal Instruction Violation",
            "IllegalInstruction",
            "An illegal instruction exception indicates that the attacker controls execution flow.",
            true,
        },

        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_PRIVILEGED_INSTRUCTION,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Privileged Instruction Violation",
            "PrivilegedInstruction",
            "A privileged instruction exception indicates that the attacker controls execution flow.",
            true,
        },

        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_GUARD_PAGE_VIOLATION,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Guard Page Violation",
            "GuardPage",
            "",
            true,
        },

        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_STACK_BUFFER_OVERRUN,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Stack Buffer Overrun (/GS Exception)",
            "GSViolation",
            "An overrun of a protected stack buffer has been detected. This is considered exploitable, and must be fixed.",
            true,
        },


        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_HEAP_CORRUPTION,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Heap Corruption",
            "HeapCorruption",
            "Heap Corruption has been detected. This is considered exploitable, and must be fixed.",
            true,
        },

        {
            KERNEL,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_DEP,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Kernel Mode Data Execution Prevention Violation",
            "DEPViolation",
            "All kernel mode DEP access violations are exploitable.",
            true,
        },

        {
            USER,
            NOT_NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_DEP,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Data Execution Prevention Violation",
            "DEPViolation",
            "User mode DEP access violations are exploitable.",
            true,
        },

        {
            KERNEL,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingAddressInstructionPointer, this ),
            EXPLOITABLE,
            "Kernel Mode Read Access Violation at the Instruction Pointer",
            "ReadAVonIP",
            "All kernel access violations at the instruction pointer are exploitable.",
            true,
        },

        {
            USER,
            NOT_NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingAddressInstructionPointer, this ),
            EXPLOITABLE,
            "Read Access Violation at the Instruction Pointer",
            "ReadAVonIP",
            "Access violations at the instruction pointer are exploitable if not near NULL.",
            true,
        },

        {
            USER,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            DONT_CARE_EXCEPTION_TYPE,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::WasExceptionHandlerChainCorrupted, this ),
            EXPLOITABLE,
            "Exception Handler Chain Corrupted",
            "ExceptionHandlerCorrupted",
            "Corruption of the exception handler chain is considered exploitable",
            true,
        },

        {
            USER,
            NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_DEP,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            PROBABLY_EXPLOITABLE,
            "Data Execution Prevention Violation near NUL",
            "DEPViolation",
            "User mode DEP access violations are probably exploitable if near NULL.",
            true,
        },

        {
            USER,
            NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingAddressInstructionPointer, this ),
            PROBABLY_EXPLOITABLE,
            "Read Access Violation Near Null at the Instruction Pointer",
            "ReadAVonIP",
            "Access violations at the instruction pointer are probably exploitable if near NULL.",
            true,
        },

        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::canFaultingInstructionNotBeDisassebled, this ),
            PROBABLY_EXPLOITABLE,
            "Cannot disassemble instruction",
            "ReadAvOnIP",
            "There is no memory backing the instruction pointer. Disassembly of instruction failed.",
            true,
        },

        {
            USER,
            NOT_NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_WRITE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "User Mode Write AV",
            "WriteAV",
            "User mode write access violations that are not near NULL are exploitable.",
            true,
        },

        {
            KERNEL,
            IN_KERNEL_MEMORY,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_WRITE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Write Access Violation in Kernel Memory",
            "WriteAV",
            "All kernel mode write access violations in kernel memory are exploitable.",
            true,
        },

        {
            KERNEL,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_WRITE,
            SECOND_CHANCE,
            nullptr,
            EXPLOITABLE,
            "Write Access Violation in Kernel Mode",
            "WriteAV",
            "All kernel mode second chance write access violations are exploitable.",
            true,
        },

        {
            KERNEL,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingInstructionControlFlow, this ),
            EXPLOITABLE,
            "Kernel Read Access Violation on Control Flow",
            "ReadAVonControlFlow",
            "All kernel access violations in control flow instructions are considered exploitable.",
            true,
        },

        {
            USER,
            NOT_NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingInstructionControlFlow, this ),
            EXPLOITABLE,
            "Read Access Violation on Control Flow",
            "ReadAVonControlFlow",
            "Access violations not near null in control flow instructions are considered exploitable.",
            true,
        },

        {
            USER,
            NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingInstructionControlFlow, this ),
            PROBABLY_EXPLOITABLE,
            "Read Access Violation on Control Flow",
            "ReadAVonControlFlow",
            "Access violations near null in control flow instructions are considered probably exploitable.",
            true,
        },

        {
            USER,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingInstructionBlockDataMove, this ),
            PROBABLY_EXPLOITABLE,
            "Read Access Violation on Block Data Move",
            "ReadAVonBlockMove",
            "This is a read access violation in a block data move, and is therefore classified as probably exploitable.",
            true,
        },

        {
            KERNEL,
            IN_KERNEL_MEMORY,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingInstructionBlockDataMove, this ),
            PROBABLY_EXPLOITABLE,
            "Kernel Memory Read Access Violation on Block Data Move",
            "ReadAVonBlockMove",
            "This is a read access violation in a kernel memory block data move, and is therefore classified as probably exploitable.",
            true,
        },

        {
            KERNEL,
            IN_USER_MEMORY,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            SECOND_CHANCE,
            bind( &XploitabilityBangExploitable::isFaultingInstructionBlockDataMove, this ),
            PROBABLY_EXPLOITABLE,
            "Memory Read Access Violation on Block Data Move",
            "ReadAVonBlockMove",
            "This is a second chance read access violation in a kernel mode block data move, and is therefore classified as probably exploitable.",
            true,
        },

        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isTaintedDataUsedToDetermineBranchTarget, this ),
            PROBABLY_EXPLOITABLE,
            "Data from Faulting Address controls Code Flow",
            "TaintedDataControlsCodeFlow",
            "The data from the faulting address is later used as the target for a branch.",
            true,
        },

        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isTaintedDataUsedInALaterWrite, this ),
            PROBABLY_EXPLOITABLE,
            "Data from Faulting Address controls subsequent Write Address",
            "TaintedDataControlsWriteAddress",
            "The data from the faulting address is later used as the target for a later write.",
            true,
        },

        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            DONT_CARE_EXCEPTION_TYPE,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::WasApplicationVerifierStopDetected, this ),
            UNKNOWN,
            "Application Verifier Stop",
            "AppVerifierStop",
            "An Application Verifier Stop was detected, but no additional security details could be determined. This fault must be manually investigated.",
            true,
        },

        {
            USER,
            NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            NOT_LIKELY_EXPLOITABLE,
            "Read Access Violation near NUL",
            "ReadAVNearNull",
            "This is a user mode read access violation near null, and is probably not exploitable.",
            true,
        },

        {
            KERNEL,
            IN_USER_MEMORY,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            FIRST_CHANCE,
            nullptr,
            NOT_LIKELY_EXPLOITABLE,
            "First Chance Kernel Read Access Violation in User Memory",
            "ReadAV",
            "This is a kernel mode first chance read access violation in user memory, and is probably not exploitable.",
            false,
        },

        {
            KERNEL,
            IN_USER_MEMORY,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_WRITE,
            FIRST_CHANCE,
            nullptr,
            NOT_LIKELY_EXPLOITABLE,
            "First Chance Kernel Write Access Violation in User Memory",
            "WriteAV",
            "This is a kernel mode first chance write access violation in user memory, and is probably not exploitable.",
            false,
        },

        {
            USER,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_INTEGER_DIVIDE_BY_ZERO,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            NOT_LIKELY_EXPLOITABLE,
            "Integer Divide By Zero",
            "DivideByZero",
            "This is a divide by zero, and is probably not exploitable.",
            false,
        },

        {
            USER,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_FLOAT_DIVIDE_BY_ZERO,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            NOT_LIKELY_EXPLOITABLE,
            "Float Divide By Zero",
            "DivideByZero",
            "This is a divide by zero, and is probably not exploitable.",
            false,
        },

        {
            USER,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_STACK_OVERFLOW,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            NOT_LIKELY_EXPLOITABLE,
            "Stack Exhaustion",
            "StackExhaustion",
            "Stack Exhaustion is considered to be probably not exploitable.",
            false,
        },

        {
            USER,
            NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_WRITE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            UNKNOWN,
            "User Mode Write AV near NUL",
            "WriteAVNearNull",
            "User mode write access violations that are near NULL are unknown.",
            false,
        },

        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_WX86_BREAKPOINT,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            UNKNOWN,
            "Breakpoint",
            "Breakpoint",
            "While a breakpoint itself is probably not exploitable, it may also be an indication that an attacker is testing a target. In either case breakpoints should not exist in production code.",
            false,
        },

        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_BREAKPOINT,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            UNKNOWN,
            "Breakpoint",
            "Breakpoint",
            "While a breakpoint itself is probably not exploitable, it may also be an indication that an attacker is testing a target. In either case breakpoints should not exist in production code.",
            false,
        },

        {
            KERNEL,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_BREAKPOINT,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::WasBugCheckDetected, this ),
            UNKNOWN,
            "BugCheck",
            "BugCheck",
            "A BugCheck was detected, but no further information about the severity could be determined.",
            false,
        },

        {
            USER,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            DONT_CARE_EXCEPTION_TYPE,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::doesStackTraceContainUnknownFunctions, this ),
            UNKNOWN,
            "Possible Stack Corruption",
            "PossibleStackCorruption",
            "The stack trace contains one or more locations for which no symbol or module could be found. This may be a sign of stack corruption.",
            false,
        },

        {
            KERNEL,
            NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            UNKNOWN,
            "Kernel Read Access Violation near NUL",
            "ReadAVNearNull",
            "This is a kernel mode read access violation near null.",
            false,
        },

        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isTaintedDataUsedAsSourceForBlockDataMove, this ),
            UNKNOWN,
            "Data from Faulting Address is used in a subsequent Block Data Move",
            "TaintedDataUsedInBlockMove",
            "The data from the faulting address is later used as the input for a later block data move.",
            false,
        },

        {
            KERNEL,
            IN_USER_MEMORY,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            FIRST_CHANCE,
            bind( &XploitabilityBangExploitable::isFaultingInstructionBlockDataMove, this ),
            UNKNOWN,
            "Memory Read Access Violation on Block Data Move",
            "ReadAVonBlockMove",
            "This is a first chance read access violation in a kernel mode block data move. If the attacker controls the size of the move, this may represent a security issue.",
            false,
        },

        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isTaintedDataUsedAsAFunctionArgument, this ),
            UNKNOWN,
            "Data from Faulting Address is used as one or more arguments in a subsequent Function Call",
            "TaintedDataPassedToFunction",
            "The data from the faulting address is later used as one or more of the arguments to a function call.",
            false,
        },

        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isTaintedDataUsedAsAFunctionRetVal, this ),
            UNKNOWN,
            "Data from Faulting Address may be used as a return value",
            "TaintedDataReturnedFromFunction",
            "The data from the faulting address may later be used as a return value from this function.",
            false,
        },

        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isTaintedDataUsedToDetermineBranchSelection, this ),
            UNKNOWN,
            "Data from Faulting Address controls Branch Selection",
            "TaintedDataControlsBranchSelection",
            "The data from the faulting address is later used to determine whether or not a branch is taken.",
            false,
        }
    
    };


    for( BangRule& rule : rules ) {

        // We don't care about kernel stuff
        if( rule.processorMode==KERNEL ) {
            continue;
        }
        
        // Process the area where the exception occurred
        if( ( rule.exceptionAddressRange != DONT_CARE_EXCEPTION_ADDRESS_RANGE ) 
            && 
                ( ((rule.exceptionAddressRange == IN_KERNEL_MEMORY) 
                    && isExceptionAddressInUser()) ||
                ( (rule.exceptionAddressRange  == IN_USER_MEMORY) 
                    && !isExceptionAddressInUser()) ||
                ( (rule.exceptionAddressRange  == NEAR_NULL) 
                    && !isExceptionAddressNearNull()) ||
                ( (rule.exceptionAddressRange  == NOT_NEAR_NULL) 
                && isExceptionAddressNearNull()) ) ) {
            continue;
        }

        // Check exception type
        if( rule.exceptionType != DONT_CARE_EXCEPTION_TYPE) {            
            if( rule.exceptionType != exceptionType()  )  {
                continue;
            }
        }

        // Check exception subtype
        if( (rule.exceptionSubtype != DONT_CARE_EXCEPTION_SUBTYPE ) && 
                rule.exceptionSubtype != exceptionSubtype() ) {
            continue;
        }

        // Everything passed so far, run the analysis function
        if( rule.analyzeFunction ) {
            if( !rule.analyzeFunction() ) {
                continue;
            }
        }

        // This rule is not final, so keep on going
        if( !rule.isFinal ) {
            continue;
        }

        return rule;
    }

    // Couldn't find anything
    return BangRule {
        DONT_CARE_PROCESSOR_MODE,
        DONT_CARE_EXCEPTION_ADDRESS_RANGE,
        DONT_CARE_EXCEPTION_TYPE,
        DONT_CARE_EXCEPTION_SUBTYPE,
        DONT_CARE_EXCEPTION_LEVEL,
        nullptr,
        NOT_AN_EXCEPTION,
        "Unknown",
        "Unknown",
        "Nothing matched",
        true,
    };

    
}

/**
 *  operator<<() - converts between exploitability enum forms
 */
XploitabilityResult& operator<<( XploitabilityResult& result, BangRule& rule ) {
    switch(rule.resultClassification) {
        case EXPLOITABLE:
            result.rank = XploitabilityRank::XPLOITABILITY_HIGH;
            break;
        case PROBABLY_EXPLOITABLE:
            result.rank = XploitabilityRank::XPLOITABILITY_MEDIUM;
            break;
        case NOT_LIKELY_EXPLOITABLE:
            result.rank = XploitabilityRank::XPLOITABILITY_LOW;
            break;
        case UNKNOWN:
            result.rank = XploitabilityRank::XPLOITABILITY_UNKNOWN;
            break;
        default:
            result.rank = XploitabilityRank::XPLOITABILITY_NONE;

    }
    return result;
}

/**
 * main Xploitability process method
 * @return
 */
XploitabilityResult XploitabilityBangExploitable::process() {    
    BangRule& rule = processRules();
    XploitabilityResult result(name());
    result << rule;
    return result;
}



} // namespace