#include "Xploitability.h"
#include "XploitabilityBangExploitable.h"
#include "google_breakpad/common/minidump_exception_win32.h"

#include <functional>
#include <cstdlib>
#include <unordered_set>

using namespace std;

namespace sl2 {

XploitabilityBangExploitable::XploitabilityBangExploitable(Minidump *dump,
        ProcessState *process_state)
        : Xploitability(dump, process_state, "!exploitable") {
    
    cout << "XploitabilityBangExploitable" << endl;
}

////////////////////////////////////////////////////////////////////////////
// canFaultingInstructionNotBeDisassebled()
//      Returns false we can disassemble at pc
const bool XploitabilityBangExploitable::canFaultingInstructionNotBeDisassebled() const { 

    if(!memoryAvailable_)
        return false;
    if(!disassembler_)
        return false;
    
    
    return !disassembler_->currentInstructionValid();
    
}

////////////////////////////////////////////////////////////////////////////
// doesStackTraceContainUnknownFunctions
//      This information isn't easily available in breakpad
const bool XploitabilityBangExploitable::doesStackTraceContainUnknownFunctions() const { 
    return false; 
}

////////////////////////////////////////////////////////////////////////////
// isEventNotAnException()
//      Checks exceptionCode_ against all possible valid windows exception
const bool XploitabilityBangExploitable::isEventNotAnException() const { 
    unordered_set<MDExceptionCodeWin> validExceptions = {
        MD_EXCEPTION_CODE_WIN_CONTROL_C,
        MD_EXCEPTION_CODE_WIN_GUARD_PAGE_VIOLATION,
        MD_EXCEPTION_CODE_WIN_ACCESS_VIOLATION,
        MD_EXCEPTION_CODE_WIN_ARRAY_BOUNDS_EXCEEDED,
        MD_EXCEPTION_CODE_WIN_BAD_FUNCTION_TABLE,
        MD_EXCEPTION_CODE_WIN_BREAKPOINT,
        MD_EXCEPTION_CODE_WIN_DATATYPE_MISALIGNMENT,
        MD_EXCEPTION_CODE_WIN_FLOAT_DENORMAL_OPERAND,
        MD_EXCEPTION_CODE_WIN_FLOAT_DIVIDE_BY_ZERO,
        MD_EXCEPTION_CODE_WIN_FLOAT_INEXACT_RESULT,
        MD_EXCEPTION_CODE_WIN_FLOAT_INVALID_OPERATION,
        MD_EXCEPTION_CODE_WIN_FLOAT_OVERFLOW,
        MD_EXCEPTION_CODE_WIN_FLOAT_STACK_CHECK,
        MD_EXCEPTION_CODE_WIN_FLOAT_UNDERFLOW,
        MD_EXCEPTION_CODE_WIN_HEAP_CORRUPTION,
        MD_EXCEPTION_CODE_WIN_ILLEGAL_INSTRUCTION,
        MD_EXCEPTION_CODE_WIN_INTEGER_DIVIDE_BY_ZERO,
        MD_EXCEPTION_CODE_WIN_INTEGER_OVERFLOW,
        MD_EXCEPTION_CODE_WIN_INVALID_DISPOSITION,
        MD_EXCEPTION_CODE_WIN_INVALID_HANDLE,
        MD_EXCEPTION_CODE_WIN_IN_PAGE_ERROR,
        MD_EXCEPTION_CODE_WIN_NONCONTINUABLE_EXCEPTION,
        MD_EXCEPTION_CODE_WIN_POSSIBLE_DEADLOCK,
        MD_EXCEPTION_CODE_WIN_PRIVILEGED_INSTRUCTION,
//        MD_EXCEPTION_CODE_WIN_SIMULATED,
        MD_EXCEPTION_CODE_WIN_SINGLE_STEP,
        MD_EXCEPTION_CODE_WIN_STACK_BUFFER_OVERRUN,
        MD_EXCEPTION_CODE_WIN_STACK_OVERFLOW,
//        MD_EXCEPTION_CODE_WIN_UNHANDLED_CPP_EXCEPTION,
        MD_EXCEPTION_OUT_OF_MEMORY
    };


    for( auto exc : validExceptions ) {
        if( exc==exceptionCode_ ) {
            return false;
        }
    }
    return true;
}

////////////////////////////////////////////////////////////////////////////
// isFaultingAddressInstructionPointer()
//      Returns true if pc is the crashing memory address
const bool XploitabilityBangExploitable::isFaultingAddressInstructionPointer() const { 
    return instructionPtr_ == process_state_->crash_address();
}


////////////////////////////////////////////////////////////////////////////
// isFaultingInstructionBlockDataMove
//      They call a block data move a move with a rep (on x86)
const bool XploitabilityBangExploitable::isFaultingInstructionBlockDataMove() const { 
    if(!disassembler_)
        return false;
    auto instr = disassembler_->currentInstruction();
    if( nullptr == instr )
        return false;

    auto group = disassembler_->currentInstructionGroup() ;

    return group == libdis::insn_move &&    
            (
                (instr->prefix & libdis::insn_rep_zero) ||
                (instr->prefix & libdis::insn_rep_notzero)
            );        
}

////////////////////////////////////////////////////////////////////////////
const bool XploitabilityBangExploitable::isFaultingInstructionControlFlow() const { 
    if(!disassembler_)
        return false;
    auto instr = disassembler_->currentInstruction();
    if( nullptr == instr )
        return false;

    auto group = disassembler_->currentInstructionGroup() ;

    return group == libdis::insn_controlflow; 
}

////////////////////////////////////////////////////////////////////////////
const bool XploitabilityBangExploitable::isFaultingInstructionInUserland() const { 
    return instructionPtr_ <= 0x7fffffffffffffff;    
}


////////////////////////////////////////////////////////////////////////////
const bool XploitabilityBangExploitable::isFaultingInstructionOnStack()const {
    uint64_t delta = abs( (int64_t)(instructionPtr_ - stackPtr_) );

    if( delta<40960 ) {
        return true;
    }
    return false;
}


const bool XploitabilityBangExploitable::isTaintedDataUsedAsAFunctionArgument() const { return false; }
const bool XploitabilityBangExploitable::isTaintedDataUsedAsAFunctionRetVal() const { return false; }
const bool XploitabilityBangExploitable::isTaintedDataUsedAsSourceForBlockDataMove() const { return false; }
const bool XploitabilityBangExploitable::isTaintedDataUsedInALaterWrite() const { return false; }

////////////////////////////////////////////////////////////////////////////
// isTaintedDataUsedToDetermineBranchSelection()
//      Tries to figure out if branch is based on tained data
const bool XploitabilityBangExploitable::isTaintedDataUsedToDetermineBranchSelection() const {
    return false; 
}

const bool XploitabilityBangExploitable::isTaintedDataUsedToDetermineBranchTarget() const { return false; }
const bool XploitabilityBangExploitable::WasApplicationVerifierStopDetected() const { return false; }
const bool XploitabilityBangExploitable::WasBugCheckDetected() const { return false; }
const bool XploitabilityBangExploitable::WasExceptionHandlerChainCorrupted() const { return false; }



ExceptionType XploitabilityBangExploitable::exceptionType() {

    switch(exceptionCode_) {
        case MD_EXCEPTION_CODE_WIN_CONTROL_C:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_GUARD_PAGE_VIOLATION:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_DATATYPE_MISALIGNMENT:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_BREAKPOINT:
                return STATUS_BREAKPOINT;
        case MD_EXCEPTION_CODE_WIN_SINGLE_STEP:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_ACCESS_VIOLATION:
                return STATUS_ACCESS_VIOLATION;
        case MD_EXCEPTION_CODE_WIN_IN_PAGE_ERROR:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_INVALID_HANDLE:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_ILLEGAL_INSTRUCTION:
                return STATUS_ILLEGAL_INSTRUCTION;
        case MD_EXCEPTION_CODE_WIN_NONCONTINUABLE_EXCEPTION:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_INVALID_DISPOSITION:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_ARRAY_BOUNDS_EXCEEDED:
                return STATUS_ACCESS_VIOLATION;
        case MD_EXCEPTION_CODE_WIN_FLOAT_DENORMAL_OPERAND:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_FLOAT_DIVIDE_BY_ZERO:
                return STATUS_FLOAT_DIVIDE_BY_ZERO;
        case MD_EXCEPTION_CODE_WIN_FLOAT_INEXACT_RESULT:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_FLOAT_INVALID_OPERATION:
                return STATUS_ILLEGAL_INSTRUCTION;
        case MD_EXCEPTION_CODE_WIN_FLOAT_OVERFLOW:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_FLOAT_STACK_CHECK:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_FLOAT_UNDERFLOW:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_INTEGER_DIVIDE_BY_ZERO:
                return STATUS_INTEGER_DIVIDE_BY_ZERO;
        case MD_EXCEPTION_CODE_WIN_INTEGER_OVERFLOW:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_PRIVILEGED_INSTRUCTION:
                return STATUS_PRIVILEGED_INSTRUCTION;
        case MD_EXCEPTION_CODE_WIN_STACK_OVERFLOW:
                return STATUS_STACK_OVERFLOW;
        case MD_EXCEPTION_CODE_WIN_BAD_FUNCTION_TABLE:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_POSSIBLE_DEADLOCK:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_STACK_BUFFER_OVERRUN:
                return STATUS_STACK_BUFFER_OVERRUN;
        case MD_EXCEPTION_CODE_WIN_HEAP_CORRUPTION:
                return STATUS_HEAP_CORRUPTION;
        case MD_EXCEPTION_OUT_OF_MEMORY:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_UNHANDLED_CPP_EXCEPTION:
                return STATUS_UNKNOWN;
        case MD_EXCEPTION_CODE_WIN_SIMULATED:
                return STATUS_UNKNOWN;
        default:
                return STATUS_UNKNOWN;
    }

}

ExceptionSubtype XploitabilityBangExploitable::exceptionSubtype() {

    if( rawException_->exception_record.number_parameters < 1)
        return DONT_CARE_EXCEPTION_SUBTYPE;

    auto avType = static_cast<MDAccessViolationTypeWin>
        (rawException_->exception_record.exception_information[0]);

    switch (avType) {
        case MD_ACCESS_VIOLATION_WIN_READ:
            return ACCESS_VIOLATION_TYPE_READ;
        case MD_ACCESS_VIOLATION_WIN_WRITE:
            return ACCESS_VIOLATION_TYPE_WRITE;
        case MD_ACCESS_VIOLATION_WIN_EXEC:
            return ACCESS_VIOLATION_TYPE_DEP;
        default:
            return DONT_CARE_EXCEPTION_SUBTYPE;
    }

}

BangRule XploitabilityBangExploitable::processRules() {

    cout << "processRules" << endl;
    vector<BangRule> rules = {
	// Gather and report the initial state of the debugger
	//
	// Note that we don't report the stack information here, because we may gather it multiple times as we find
	// better contexts within which to work. Because of this, stack information is actually reported by the rules
	// engine itself
	// Rule: If the event in the debugger is not an exception, we are unable to continue any further with our
	//		 analysis, and we terminate   

    
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            DONT_CARE_EXCEPTION_TYPE,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,        
            bind( &XploitabilityBangExploitable::isEventNotAnException, this ),
            NOT_AN_EXCEPTION,
            "",
            "NotException",
            "The current event is not an exception. No further analysis will be done.",
            true,
        },


        // Rule: If the exception is a Debugger Wake event, no further processing is necessary, something unusual has happened,
        //       we don't know what, and we don't have any way to get additional data
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_WAKE_SYSTEM_DEBUGGER,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            UNKNOWN,
            "",
            "DebuggerWakeEvent",
            "The application has requested a Debugger Wake event. This should not happen during normal operations, and should be investigated.",

            true,
        },

        // Rule: Any exception in which the faulting instruction is executing from the stack is exploitable
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            DONT_CARE_EXCEPTION_TYPE,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingInstructionOnStack, this ),
            EXPLOITABLE,
            "Exception generated by code running in the Stack",
            "StackCodeExecution",
            "Code execution from the stack is considered exploitable",

            true,
        },

        // Rule: Any exception in kernel mode where the faulting instruction is executing from user space is exploitable
        {
            KERNEL,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            DONT_CARE_EXCEPTION_TYPE,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingInstructionInUserland, this ),
            EXPLOITABLE,
            "Kernel Exception in Userland",
            "KernelExceptionInUserland",
            "Any exception occurring in kernel mode where the code is in Userland is considered exploitable",

            true,
        },

        // Rule: Illegal instruction exceptions indicate that program flow has been controlled by an attacker
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ILLEGAL_INSTRUCTION,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Illegal Instruction Violation",
            "IllegalInstruction",
            "An illegal instruction exception indicates that the attacker controls execution flow.",

            true,
        },

        // Rule: Privileged  instruction exceptions indicate that program flow has been controlled by an attacker
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_PRIVILEGED_INSTRUCTION,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Privileged Instruction Violation",
            "PrivilegedInstruction",
            "A privileged instruction exception indicates that the attacker controls execution flow.",

            true,
        },

        // Rule: All Guard Page exceptions must be fixed
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_GUARD_PAGE_VIOLATION,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Guard Page Violation",
            "GuardPage",
            "",

            true,
        },

        // Rule: Stack Buffer Overruns (/GS Exceptions) must be fixed
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_STACK_BUFFER_OVERRUN,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Stack Buffer Overrun (/GS Exception)",
            "GSViolation",
            "An overrun of a protected stack buffer has been detected. This is considered exploitable, and must be fixed.",

            true,
        },

        // Rule: Heap Corruption is considered exploitable
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_HEAP_CORRUPTION,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Heap Corruption",
            "HeapCorruption",
            "Heap Corruption has been detected. This is considered exploitable, and must be fixed.",

            true,
        },

        // Rule: All DEP violations in kernal mode are exploitable
        {
            KERNEL,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_DEP,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Kernel Mode Data Execution Prevention Violation",
            "DEPViolation",
            "All kernel mode DEP access violations are exploitable.",

            true,
        },

        // Rule: DEP violations in user mode are exploitable if not near null
        {
            USER,
            NOT_NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_DEP,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Data Execution Prevention Violation",
            "DEPViolation",
            "User mode DEP access violations are exploitable.",

            true,
        },

        // Rule: AVs at the instruction pointer are exploitable if in kernel mode
        {
            KERNEL,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingAddressInstructionPointer, this ),
            EXPLOITABLE,
            "Kernel Mode Read Access Violation at the Instruction Pointer",
            "ReadAVonIP",
            "All kernel access violations at the instruction pointer are exploitable.",

            true,
        },

        // Rule: AVs at the instruction pointer are exploitable if not near null in user mode
        {
            USER,
            NOT_NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingAddressInstructionPointer, this ),
            EXPLOITABLE,
            "Read Access Violation at the Instruction Pointer",
            "ReadAVonIP",
            "Access violations at the instruction pointer are exploitable if not near NULL.",

            true,
        },


        // Rule: Corrupted exception handler chains are always exploitable
        {
            USER,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            DONT_CARE_EXCEPTION_TYPE,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::WasExceptionHandlerChainCorrupted, this ),
            EXPLOITABLE,
            "Exception Handler Chain Corrupted",
            "ExceptionHandlerCorrupted",
            "Corruption of the exception handler chain is considered exploitable",

            true,
        },

        // Rule: DEP violations in user mode are probably exploitable if near null
        {
            USER,
            NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_DEP,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            PROBABLY_EXPLOITABLE,
            "Data Execution Prevention Violation near NUL",
            "DEPViolation",
            "User mode DEP access violations are probably exploitable if near NULL.",

            true,
        },

        // Rule: AVs at the instruction pointer are probably exploitable if near null in user mode
        {
            USER,
            NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingAddressInstructionPointer, this ),
            PROBABLY_EXPLOITABLE,
            "Read Access Violation Near Null at the Instruction Pointer",
            "ReadAVonIP",
            "Access violations at the instruction pointer are probably exploitable if near NULL.",

            true,
        },



        // Rule: check if the instruction pointer can be un assembled if not, execution is way off.
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::canFaultingInstructionNotBeDisassebled, this ),
            PROBABLY_EXPLOITABLE,
            "Cannot disassemble instruction",
            "ReadAvOnIP",
            "There is no memory backing the instruction pointer. Disassembly of instruction failed.",

            true,
        },



        // Rule: All user mode Write Access violations are exploitable if not near null
        {
            USER,
            NOT_NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_WRITE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "User Mode Write AV",
            "WriteAV",
            "User mode write access violations that are not near NULL are exploitable.",

            true,
        },



        // Rule: Kernel mode first chance write exceptions are exploitable if the address is in kernel memory
        {
            KERNEL,
            IN_KERNEL_MEMORY,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_WRITE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            EXPLOITABLE,
            "Write Access Violation in Kernel Memory",
            "WriteAV",
            "All kernel mode write access violations in kernel memory are exploitable.",

            true,
        },

        // Rule: Kernel mode second chance write exceptions are exploitable
        {
            KERNEL,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_WRITE,
            SECOND_CHANCE,
            nullptr,
            EXPLOITABLE,
            "Write Access Violation in Kernel Mode",
            "WriteAV",
            "All kernel mode second chance write access violations are exploitable.",

            true,
        },

        // Rule: AVs on control flow are considered exploitable in the kernel
        {
            KERNEL,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingInstructionControlFlow, this ),
            EXPLOITABLE,
            "Kernel Read Access Violation on Control Flow",
            "ReadAVonControlFlow",
            "All kernel access violations in control flow instructions are considered exploitable.",

            true,
        },

        // Rule: AVs on control flow are considered exploitable in user mode if not near null
        {
            USER,
            NOT_NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingInstructionControlFlow, this ),
            EXPLOITABLE,
            "Read Access Violation on Control Flow",
            "ReadAVonControlFlow",
            "Access violations not near null in control flow instructions are considered exploitable.",

            true,
        },

        // Rule: AVs on control flow are considered probably exploitable in user mode if near null
        {
            USER,
            NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingInstructionControlFlow, this ),
            PROBABLY_EXPLOITABLE,
            "Read Access Violation on Control Flow",
            "ReadAVonControlFlow",
            "Access violations near null in control flow instructions are considered probably exploitable.",

            true,
        },

        // Rule: Read AVS in a block move are considered probably exploitable
        {
            USER,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingInstructionBlockDataMove, this ),
            PROBABLY_EXPLOITABLE,
            "Read Access Violation on Block Data Move",
            "ReadAVonBlockMove",
            "This is a read access violation in a block data move, and is therefore classified as probably exploitable.",

            true,
        },

        // Rule: Read AVS in a block move are considered probably exploitable
        {
            KERNEL,
            IN_KERNEL_MEMORY,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isFaultingInstructionBlockDataMove, this ),
            PROBABLY_EXPLOITABLE,
            "Kernel Memory Read Access Violation on Block Data Move",
            "ReadAVonBlockMove",
            "This is a read access violation in a kernel memory block data move, and is therefore classified as probably exploitable.",

            true,
        },

        // Rule: Read AVS in a block move are considered probably exploitable
        {
            KERNEL,
            IN_USER_MEMORY,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            SECOND_CHANCE,
            bind( &XploitabilityBangExploitable::isFaultingInstructionBlockDataMove, this ),
            PROBABLY_EXPLOITABLE,
            "Memory Read Access Violation on Block Data Move",
            "ReadAVonBlockMove",
            "This is a second chance read access violation in a kernel mode block data move, and is therefore classified as probably exploitable.",

            true,
        },


        // Rule: Tainted information used to control branch addresses is considered probably exploitable
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isTaintedDataUsedToDetermineBranchTarget, this ),
            PROBABLY_EXPLOITABLE,
            "Data from Faulting Address controls Code Flow",
            "TaintedDataControlsCodeFlow",
            "The data from the faulting address is later used as the target for a branch.",

            true,
        },

        // Rule: Tainted information used to control the target of a later write is probably exploitable
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isTaintedDataUsedInALaterWrite, this ),
            PROBABLY_EXPLOITABLE,
            "Data from Faulting Address controls subsequent Write Address",
            "TaintedDataControlsWriteAddress",
            "The data from the faulting address is later used as the target for a later write.",

            true,
        },


        // Rule: Application Verifier Stops are called out as unknown
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            DONT_CARE_EXCEPTION_TYPE,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::WasApplicationVerifierStopDetected, this ),
            UNKNOWN,
            "Application Verifier Stop",
            "AppVerifierStop",
            "An Application Verifier Stop was detected, but no additional security details could be determined. This fault must be manually investigated.",

            true,
        },


        //
        // Probably Not Exploitable Terminal Rules
        //
        // These are rules where further analysis has shown that it isn't worth human evaluation, even if there
        // are other mitigating circumstances
        //

        // Rule: User Mode Read AVs near null are considered probably not exploitable
        {
            USER,
            NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            NOT_LIKELY_EXPLOITABLE,
            "Read Access Violation near NUL",
            "ReadAVNearNull",
            "This is a user mode read access violation near null, and is probably not exploitable.",

            true,
        },

        //
        // All non-final rules should be evaulated here. Please note that execution order is very important,
        // as each successive rule could override a previous rules results
        //

        // 
        // Probably Not Exploitable Non-Terminal Rules
        //

        // Rule: First chance read AVs from user memory in the kernel are not considered exploitable
        {
            KERNEL,
            IN_USER_MEMORY,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            FIRST_CHANCE,
            nullptr,
            NOT_LIKELY_EXPLOITABLE,
            "First Chance Kernel Read Access Violation in User Memory",
            "ReadAV",
            "This is a kernel mode first chance read access violation in user memory, and is probably not exploitable.",

            false,
        },

        // Rule: First chance write AVs from user memory in the kernel are not considered exploitable
        {
            KERNEL,
            IN_USER_MEMORY,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_WRITE,
            FIRST_CHANCE,
            nullptr,
            NOT_LIKELY_EXPLOITABLE,
            "First Chance Kernel Write Access Violation in User Memory",
            "WriteAV",
            "This is a kernel mode first chance write access violation in user memory, and is probably not exploitable.",

            false,
        },

        // Rule: Divide By Zero is not considered exploitable
        {
            USER,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_INTEGER_DIVIDE_BY_ZERO,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            NOT_LIKELY_EXPLOITABLE,
            "Integer Divide By Zero",
            "DivideByZero",
            "This is a divide by zero, and is probably not exploitable.",

            false,
        },

        // Rule: Divide By Zero is not considered exploitable
        {
            USER,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_FLOAT_DIVIDE_BY_ZERO,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            NOT_LIKELY_EXPLOITABLE,
            "Float Divide By Zero",
            "DivideByZero",
            "This is a divide by zero, and is probably not exploitable.",

            false,
        },

        // Rule: Stack exhaustion is not considered exploitable
        {
            USER,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_STACK_OVERFLOW,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            NOT_LIKELY_EXPLOITABLE,
            "Stack Exhaustion",
            "StackExhaustion",
            "Stack Exhaustion is considered to be probably not exploitable.",

            false,
        },

        //
        // Unknown Exploitability Non-Terminal Rules
        //

        // Rule: All user mode Write Access violations are UNKNOWN if near null
        {
            USER,
            NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_WRITE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            UNKNOWN,
            "User Mode Write AV near NUL",
            "WriteAVNearNull",
            "User mode write access violations that are near NULL are unknown.",

            false,
        },

        // Rule: Breakpoints are considered probably not exploitable, but should not occur in production code
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_WX86_BREAKPOINT,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            UNKNOWN,
            "Breakpoint",
            "Breakpoint",
            "While a breakpoint itself is probably not exploitable, it may also be an indication that an attacker is testing a target. In either case breakpoints should not exist in production code.",

            false,
        },

        // Rule: Breakpoints are considered probably not exploitable, but should not occur in production code
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_BREAKPOINT,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            UNKNOWN,
            "Breakpoint",
            "Breakpoint",
            "While a breakpoint itself is probably not exploitable, it may also be an indication that an attacker is testing a target. In either case breakpoints should not exist in production code.",

            false,
        },

        // Rule: Bug checks that we don't have special case handling for should be called out separately
        {
            KERNEL,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_BREAKPOINT,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::WasBugCheckDetected, this ),
            UNKNOWN,
            "BugCheck",
            "BugCheck",
            "A BugCheck was detected, but no further information about the severity could be determined.",

            false,
        },

        // Rule: If the stack contains unknown symbols in user mode, call that out
        {
            USER,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            DONT_CARE_EXCEPTION_TYPE,
            DONT_CARE_EXCEPTION_SUBTYPE,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::doesStackTraceContainUnknownFunctions, this ),
            UNKNOWN,
            "Possible Stack Corruption",
            "PossibleStackCorruption",
            "The stack trace contains one or more locations for which no symbol or module could be found. This may be a sign of stack corruption.",

            false,
        },

        // Rule: Kernel Mode Read AVs near NULL are considered to have an unknown exploitability
        {
            KERNEL,
            NEAR_NULL,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            nullptr,
            UNKNOWN,
            "Kernel Read Access Violation near NUL",
            "ReadAVNearNull",
            "This is a kernel mode read access violation near null.",

            false,
        },

        // Rule: Tainted information used to control the source of a later block move unknown, but called out explicitly
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isTaintedDataUsedAsSourceForBlockDataMove, this ),
            UNKNOWN,
            "Data from Faulting Address is used in a subsequent Block Data Move",
            "TaintedDataUsedInBlockMove",
            "The data from the faulting address is later used as the input for a later block data move.",

            false,
        },

        // Rule: First Chance Read AVS in a block move in the kernel are called out as unknown
        {
            KERNEL,
            IN_USER_MEMORY,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            FIRST_CHANCE,
            bind( &XploitabilityBangExploitable::isFaultingInstructionBlockDataMove, this ),
            UNKNOWN,
            "Memory Read Access Violation on Block Data Move",
            "ReadAVonBlockMove",
            "This is a first chance read access violation in a kernel mode block data move. If the attacker controls the size of the move, this may represent a security issue.",

            false,
        },

        // Rule: Tainted information used as an argument to a function is an unknown risk, but called out explicitly
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isTaintedDataUsedAsAFunctionArgument, this ),
            UNKNOWN,
            "Data from Faulting Address is used as one or more arguments in a subsequent Function Call",
            "TaintedDataPassedToFunction",
            "The data from the faulting address is later used as one or more of the arguments to a function call.",

            false,
        },

        // Rule: Tainted information returned from a function is an unknown risk, but called out explicitly
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isTaintedDataUsedAsAFunctionRetVal, this ),
            UNKNOWN,
            "Data from Faulting Address may be used as a return value",
            "TaintedDataReturnedFromFunction",
            "The data from the faulting address may later be used as a return value from this function.",

            false,
        },



        // Rule: Tainted information used to control branch selection is an unknown risk, but called out explicitly
        {
            DONT_CARE_PROCESSOR_MODE,
            DONT_CARE_EXCEPTION_ADDRESS_RANGE,
            STATUS_ACCESS_VIOLATION,
            ACCESS_VIOLATION_TYPE_READ,
            DONT_CARE_EXCEPTION_LEVEL,
            bind( &XploitabilityBangExploitable::isTaintedDataUsedToDetermineBranchSelection, this ),
            UNKNOWN,
            "Data from Faulting Address controls Branch Selection",
            "TaintedDataControlsBranchSelection",
            "The data from the faulting address is later used to determine whether or not a branch is taken.",

            false,
        }
    
    };


    for( BangRule& rule : rules ) {

        //cout << "rule: " << rule << endl;

        // We are ignoring anything in kernel mode
        if( rule.processorMode==KERNEL ) {
            continue;
        }
        
        if( ( rule.exceptionAddressRange != DONT_CARE_EXCEPTION_ADDRESS_RANGE ) 
            && 
                ( ((rule.exceptionAddressRange == IN_KERNEL_MEMORY) 
                    && isExceptionAddressInUser()) ||
                ( (rule.exceptionAddressRange  == IN_USER_MEMORY) 
                    && !isExceptionAddressInUser()) ||
                ( (rule.exceptionAddressRange  == NEAR_NULL) 
                    && !isExceptionAddressNearNull()) ||
                ( (rule.exceptionAddressRange  == NOT_NEAR_NULL) 
                && isExceptionAddressNearNull()) ) ) {
            continue;
        }

        if( rule.exceptionType != DONT_CARE_EXCEPTION_TYPE) {            
            if( rule.exceptionType != exceptionType()  )  {
                continue;
            }
        }

        if( (rule.exceptionSubtype != DONT_CARE_EXCEPTION_SUBTYPE ) && 
                rule.exceptionSubtype != exceptionSubtype() ) {
            continue;
        }

        // No exception level handling here since I believe it's only applicable to 
        // kernel mode which we aren't dealing with anyways.  

        // Make sure we have a method than analyzes
        if( rule.analyzeFunction ) {
            if( !rule.analyzeFunction() ) {
                continue;
            }
        }

        if( !rule.isFinal ) {
            continue;
        }

        return rule;
    }

    // Couldn't find anything
    return BangRule  {
        DONT_CARE_PROCESSOR_MODE,
        DONT_CARE_EXCEPTION_ADDRESS_RANGE,
        DONT_CARE_EXCEPTION_TYPE,
        DONT_CARE_EXCEPTION_SUBTYPE,
        DONT_CARE_EXCEPTION_LEVEL,
        nullptr,
        NOT_AN_EXCEPTION,
        "Unknown",
        "Unknown",
        "Nothing matched",
        true,
    };

    
}


XploitabilityResult& operator<<( XploitabilityResult& result, BangRule& rule ) {

    switch(rule.resultClassification) {
        case EXPLOITABLE:
            result.rank = XploitabilityRank::XPLOITABILITY_HIGH;
            break;
        case PROBABLY_EXPLOITABLE:
            result.rank = XploitabilityRank::XPLOITABILITY_MEDIUM;
            break;
        case NOT_LIKELY_EXPLOITABLE:
            result.rank = XploitabilityRank::XPLOITABILITY_LOW;
            break;
        case UNKNOWN:
            result.rank = XploitabilityRank::XPLOITABILITY_UNKNOWN;
            break;
        default:
            result.rank = XploitabilityRank::XPLOITABILITY_NONE;

    }
    return result;
}
    

XploitabilityResult XploitabilityBangExploitable::process() {
    
    BangRule& rule = processRules();
    XploitabilityResult result;
    cout << "winrule    : " << rule << endl;
    result << rule;
    return result;
}




} // namespace